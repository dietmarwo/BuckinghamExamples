= Example Applications of the Buckingham–Pi Theorem

This repository collects a variety of worked examples from the literature, demonstrating how to apply the Buckingham–Pi theorem in Python.

== Examples

*From BuckinghamPy*  

– Examples from Saad et al. (2021) https://www.sciencedirect.com/science/article/pii/S2352711021001291[BuckinghamPy: A Python software for dimensional analysis]  

  * https://github.com/saadgroup/BuckinghamPy/blob/master/examples.ipynb[examples.ipynb]  

  * Centrifugal Pump example in the README: https://github.com/saadgroup/BuckinghamPy/blob/master/README.md[Centrifugal Pump]

*Hydrogen Knudsen Compressor*  

– From Xie & Qian (2023) https://www.sciencedirect.com/science/article/abs/pii/S0360319923023030[Dimensional-Analysis of hydrogen Knudsen compressor]  

  * https://github.com/xqb-python/Dimensional-Analysis[Dimensional-Analysis repository]  

  * See their script: https://github.com/xqb-python/Dimensional-Analysis/blob/main/%E4%B8%AD%E5%BF%83%E5%9E%82%E7%9B%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E9%80%9F%E5%BA%A6%E5%88%86%E5%B8%83/%E6%9C%80%E5%A4%A7%E6%BB%91%E7%A7%BB%E9%80%9F%E5%BA%A6.py[Hydrogen Knudsen Compressor Code]

*Optimierung von Stahlgießprozessen*  

– From Lichtenberg (2021) “Optimierung von Stahlgießprozessen anhand eines Wassermodells mit begleitender Strömungssimulation”  

  * https://repo.bibliothek.uni-halle.de/handle/1981185920/87855[Dissertation repository]

*Several more Problems*

* Forced Convection over a Cylinder
  + Variables: `['Nu', 'Re', 'Pr', 'L/D', 'k', 'rho', 'c_p', 'mu']`
  + Dimension matrix:
    ```
    [   0,  0,  0,   0,   1,    1,   0,    1]   # M
    [   0,  0,  0,   0,   1,   -3,   2,   -1]   # L
    [   0,  0,  0,   0,  -3,    0,  -2,   -1]   # T
    [   0,  0,  0,   0,  -1,    0,  -1,    0]   # Θ
    ```
  + Dimensions: `['M','L','T','Θ']`
  + Target: `Nu`

* Natural Convection from a Horizontal Plate
  + Variables: `['Nu', 'Gr', 'Pr', 'L', 'beta', 'DeltaT', 'rho', 'mu', 'k', 'g']`
  + Dimension matrix:
    ```
    [   0,  0,  0,   0,   0,   0,   1,    1,   1,   0]  # M
    [   0,  0,  0,   1,   0,   0,  -3,   -1,   1,   1]  # L
    [   0,  0,  0,   0,   0,   0,   0,   -1,  -3,  -2]  # T
    [   0,  0,  0,   0,  -1,   1,   0,    0,  -1,   0]  # Θ
    ```
  + Dimensions: `['M','L','T','Θ']`
  + Target: `Nu`

* Packed-Bed Pressure Drop (Ergun)
  + Variables: `['DeltaP','rho','mu','U','D_p','epsilon','L']`
  + Dimension matrix:
    ```
    [    1,   1,  1,  0,  0,  0, 0]  # M
    [   -1,  -3, -1,  1,  1,  0, 1]  # L
    [   -2,   0, -1, -1,  0,  0, 0]  # T
    ```
  + Dimensions: `['M','L','T']`
  + Target: `DeltaP`

* Stirred-Tank Mixing (Power Number)
  + Variables: `['P','rho','N','D','mu','sigma']`
  + Dimension matrix:
    ```
    [   1,   1, 0, 0,  1,     1]  # M
    [   2,  -3, 0, 1, -1,     0]  # L
    [  -3,   0, -1,0, -1,    -2]  # T
    [   0,   0, 0, 0,  0,     0]  # Θ
    ```
  + Dimensions: `['M','L','T','Θ']`
  + Target: `P`

* Rayleigh–Bénard Convection
  + Variables: `['Nu','Ra','Pr','H','k','rho','c_p','mu','g','beta','DeltaT']`
  + Dimension matrix:
    ```
    [   0,  0, 0, 0,   1,    1,    0,    1,   0,   0,  0]  # M
    [   0,  0, 0, 1,   1,   -3,    2,   -1,   1,   0,  0]  # L
    [   0,  0, 0, 0,  -3,    0,   -2,   -1,  -2,   0,  0]  # T
    [   0,  0, 0, 0,  -1,    0,   -1,    0,   0,  -1,  1]  # Θ
    ```
  + Dimensions: `['M','L','T','Θ']`
  + Target: `Nu`

* Drop Dynamics in Shear (Ca, Re)
  + Variables: `['d','mu_c','mu_d','sigma','G','rho_c','rho_d']`
  + Dimension matrix:
    ```
    [  0,   1,   1,     1,   0,     1,     1]  # M
    [  1,  -1,  -1,     0,   0,    -3,    -3]  # L
    [  0,  -1,  -1,    -2,  -1,     0,     0]  # T
    ```
  + Dimensions: `['M','L','T']`
  + Target: `d`

* MHD Duct Flow
  + Variables: `['Ha','Re','sigma_e','B','L','rho','mu']`
  + Dimension matrix:
    ```
    [   0,  0, -1,  1,  0,  1, 1]  # M
    [   0,  0, -3,  0,  1, -3,-1]  # L
    [   0,  0,  3, -2,  0,  0,-1]  # T
    [   0,  0,  2, -1,  0,  0, 0]  # I
    ```
  + Dimensions: `['M','L','T','I']`
  + Target: `Ha`

* Aeroacoustic Dipole Radiation
  + Variables: `['p_prime','rho','U','L','c','omega','l']`
  + Dimension matrix:
    ```
    [    1,  1, 0,  0,  0,   0, 0]  # M
    [   -1, -3, 1,  1,  1,   0, 1]  # L
    [   -2,  0, -1, 0, -1,  -1, 0]  # T
    ```
  + Dimensions: `['M','L','T']`
  + Target: `p_prime`

* Laminar Forced-Convection over a Cylinder
  + Variables: `['h','D','k','U','mu','rho','c_p']`
  + Dimension matrix:
    ```
    [   1,  0,  1,  0,   1,   1,   0]   # M
    [  -2,  1,  1,  1,  -1,  -3,   2]   # L
    [  -3,  0, -3, -1,  -1,   0,  -2]   # T
    [  -1,  0, -1,  0,   0,   0,  -1]   # Θ
    ```
  + Dimensions: `['M','L','T','Θ']`
  + Target: `h`

== Python scripts

Three complementary approaches are provided:

* https://github.com/dietmarwo/BuckinghamExamples/blob/master/apply_buckinghampy.py[apply_buckinghampy.py]  
  Uses https://github.com/saadgroup/BuckinghamPy[BuckinghamPy] to enumerate all valid π-groups.

* https://github.com/dietmarwo/BuckinghamExamples/blob/master/rank_pi_groups.py[rank_pi_groups.py]  
  Uses NumPy and scikit-learn to  
  1. find all repeating-variable sets,  
  2. compute their π-groups,  
  3. score each set by the predictive R² adding a penalty for bad coefficient-of-variation over your experimental range.

* https://github.com/dietmarwo/BuckinghamExamples/blob/master/optimize_pi_groups.py[optimize_pi_groups.py]  
  1. Uses https://github.com/dietmarwo/fast-cma-es[fcmaes] to apply the https://github.com/avaneev/biteopt[biteopt] evolutionary
  algorithm to vary the pi group exponents, allowing continuous values.   
  2. score each set of pi group exponents by the predictive R² adding a penalty for bad coefficient-of-variation over your experimental range.

=== Customization

1. **Add your own examples** to the `examples` dict (variable names + dimension matrix).    
2. **Plug in your real data** (in place of the random sampling) to get π-group rankings tailored to your experiment.

== Further comparison

Compare with:  
https://github.com/xqb-python/Dimensional-Analysis/blob/main/%E4%B8%AD%E5%BF%83%E5%9E%82%E7%9B%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E9%80%9F%E5%BA%A6%E5%88%86%E5%B8%83/%E6%9C%80%E5%A4%A7%E6%BB%91%E7%A7%BB%E9%80%9F%E5%BA%A6.py[Hydrogen Knudsen Compressor Code], which uses genetic optimization. GA doesn't work well for this application, specially if you allow continuous exponents. https://www.ijche.com/article_10200_e5d7175834c141c6c71c4fe626ec5cb4.pdf[ijche2014] applies CMA-ES, but is focused on a specific problem.

== Continuous-Exponent π-Group Pipeline

Usually π-group determination requires, as a first step, choosing which variables go into which π-group (or whether to include a third group at all)—a discrete, combinatorial choice. The continuous-exponent pipeline implemented below never explicitly “chooses” which variables go into which π-group the way subset-enumeration code does. Instead, it relies on the fact that:

1. Dimensional homogeneity ⇔ Nullspace  
  Any exponent vector `E ∈ ℝⁿ` that makes '∏_{i=1}^N x_i^{E_i}' dimensionless must satisfy `A·E = 0`. 
  Computing `Ns = nullspace(A)` gives an orthonormal basis of that nullspace (shape `N×k`), 
  so every valid `E` can be written as 'E = Ns · c' for some coefficient vector `c ∈ ℝᵏ`.

2. Stacking into m π-groups  
	If you want m π-groups, choose a `k×m` matrix `C` whose columns are the `c` vectors for each π-group, 
	compute 'E = Ns · C' (an N×m matrix) and then build your π-features: 'Π_{:,j} = exp(log(X) · E_{:,j})'.
    These Πs are guaranteed dimensionless by construction.

3. Continuous optimization over C  
Frame a single continuous optimization problem over the entries of `C ∈ ℝ^{k×m}`, maximizing R² (minus your CV penalty). The evolutionary optimizer wanders around `ℝ^{k·m}`, implicitly exploring all ways of mixing the k basis-vectors into m groups. 
No discrete enumeration of “which subset of variables” is needed—the continuous weights in `C` dial in each variable’s exponent.

Because `E = Ns·C` enforces `A·E = 0`, every continuous trial `C` yields a valid set of π-groups. 
The combinatorial question “which variables in π₁ vs π₂” is thus solved implicitly 
by the optimizer finding the best continuous weights, not by manual subset enumeration.  

NOTE: The optimization library used (https://github.com/dietmarwo/fast-cma-es[fcmaes]) supports CMA-ES and several other established algorithms. 
Replacing the one used is a one-liner, but BiteOpt was chosen because of its superior flexibility:

- Tracks success statistics (e.g. which mutation scales actually produce improvements)
- Re-weights its proposal distributions “on the fly” based on those stats
- Balances exploration vs. exploitation automatically as the landscape changes


=== Citing

[source]
----
@misc{buckpiexams2025,
  author       = {Dietmar Wolz},
  title        = {Example Applications of the Buckingham–Pi Theorem},
  year         = {2025},
  publisher    = {GitHub},
  journal      = {GitHub repository},
  howpublished = {Available at \url{https://github.com/dietmarwo/BuckinghamExamples}},
}










